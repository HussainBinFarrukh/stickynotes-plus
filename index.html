<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <title>StickyNotes+ v2</title> <style> :root { --bg: #f6f7f8; --card-bg: #ffffff; --accent: #4a90e2; --text: #333333; --muted: #666666; font-family: Arial, Helvetica, sans-serif; } body { background: var(--bg); margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; } header { display: flex; align-items: center; padding: 1rem; background: var(--card-bg); box-shadow: 0 1px 4px rgba(0,0,0,0.08); gap: 0.5rem; } #searchInput { flex: 1; padding: 0.5rem 0.75rem; border: 1px solid #ccc; border-radius: 4px; font-size: 1rem; } #newNoteBtn { padding: 0.5rem 1rem; background: var(--accent); color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem; } #notesContainer { flex: 1; overflow-y: auto; padding: 1rem; display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 1rem; } .note-card { background: var(--card-bg); border-radius: 6px; padding: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 0.5rem; } .note-card h3 { margin: 0; font-size: 1.1rem; color: var(--text); } .note-card p { margin: 0; font-size: 0.9rem; color: var(--muted); white-space: pre-wrap; } .attachments { display: flex; flex-direction: column; gap: 0.25rem; } .attachment-item { font-size: 0.85rem; color: var(--accent); text-decoration: underline; cursor: pointer; } .actions { display: flex; gap: 0.5rem; margin-top: auto; } .actions button { padding: 0.25rem 0.5rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem; } .delete { background: #e74c3c; color: #fff; } .edit { background: var(--accent); color: #fff; } .drag-handle { cursor: grab; margin-right: 0.5rem; } /* Modal styling */ #modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); display: none; align-items: center; justify-content: center; } #modalContent { background: var(--card-bg); padding: 1rem; border-radius: 6px; width: 90%; max-width: 500px; display: flex; flex-direction: column; gap: 0.5rem; } #modalContent input, #modalContent textarea { width: 100%; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; font-size: 1rem; } #modalContent textarea { min-height: 80px; resize: vertical; } #attachmentList { font-size: 0.8rem; margin-top: 0.25rem; } .modal-actions { display: flex; justify-content: flex-end; gap: 0.5rem; margin-top: 0.5rem; } .modal-actions button { padding: 0.5rem 1rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; } .save-btn { background: var(--accent); color: #fff; } .cancel-btn { background: #cccccc; color: #333; } </style> </head> <body> <header> <input id="searchInput" placeholder="Search notes..." /> <button id="newNoteBtn">New Note</button> </header> <div id="notesContainer"></div> <div id="modal"> <div id="modalContent"> <label for="noteTitle">Title</label> <input id="noteTi; contentEl.innerHTML = markdownToHtml(note.content); card.appendChild(contentEl); // attachments listing if (note.attachments && note.attachments.length > 0) { const attachmentsEl = document.createElement('div'); attachmentsEl.className = 'attachments'; note.attachments.forEach(att => { const item = document.createElement('div'); item.className = 'attachment-item'; item.textContent = att.name; item.addEventListener('click', () => { if (att.type.startsWith('image')) { const win = window.open(''); win.document.write(`<img src="${att.data}" alt="${att.name}" style="max-width:100%;" />`); } else if (att.type.startsWith('audio')) { const win = window.open(''); win.document.write(`<audio controls src="${att.data}"></audio>`); } else { // other file types: trigger download const link = document.createElement('a'); link.href = att.data; link.download = att.name; link.click(); } }); attachmentsEl.appendChild(item); }); card.appendChild(attachmentsEl); } // actions (edit, delete) const actions = document.createElement('div'); actions.className = 'actions'; const editBtn = document.createElement('button'); editBtn.className = 'edit'; editBtn.textContent = 'Edit'; editBtn.onclick = () => openModal(index); const delBtn = document.createElement('button'); delBtn.className = 'delete'; delBtn.textContent = 'Delete'; delBtn.onclick = () => { if (confirm('Delete this note?')) { notes.splice(index, 1); saveToStorage(); renderNotes(); } }; actions.appendChild(editBtn); actions.appendChild(delBtn); card.appendChild(actions); // drag events for reorder card.addEventListener('dragstart', (e) => { e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', index); }); card.addEventListener('dragover', (e) => { e.preventDefault(); }); card.addEventListener('drop', (e) => { e.preventDefault(); const fromIndex = parseInt(e.dataTransfer.getData('text/plain')); const toIndex = parseInt(card.dataset.index); if (fromIndex !== toIndex) { const moved = notes.splice(fromIndex, 1)[0]; notes.splice(toIndex, 0, moved); saveToStorage(); renderNotes(); } }); notesContainer.appendChild(card); }); } function openModal(index) { editingIndex = typeof index === 'number' ? index : null; if (editingIndex !== null) { const note = notes[editingIndex]; noteTitle.value = note.title; noteContent.value = note.content; // attachments list for editing (existing attachments) attachmentList.innerHTML = ''; note.attachments.forEach(att => { const div = document.createElement('div'); div.textContent = att.name; attachmentList.appendChild(div); }); } else { noteTitle.value = ''; noteContent.value = ''; attachmentList.innerHTML = ''; } fileInput.value = ''; recordingChunks = []; modal.style.display = 'flex'; } function closeModal() { modal.style.display = 'none'; } newNoteBtn.onclick = () => openModal(null); cancelNoteBtn.onclick = closeModal; searchInput.oninput = renderNotes; // handle attachments preview on file selection fileInput.onchange = () => { const files = Array.from(fileInput.files); attachmentList.innerHTML = ''; files.forEach(f => { const div = document.createElement('div'); div.textContent = f.name; attachmentList.appendChild(div); }); }; // save note (new or edit) saveNoteBtn.onclick = () => { const title = noteTitle.value.trim(); const content = noteContent.value.trim(); // get existing attachments if editing const existing = editingIndex !== null ? notes[editingIndex].attachments.slice() : []; const files = Array.from(fileInput.files); // convert new files to data URLs Promise.all(files.map(file => { return new Promise(resolve => { const reader = new FileReader(); reader.onload = e => { resolve({ name: file.name, type: file.type, data: e.target.result }); }; reader.readAsDataURL(file); }); })).then(newAtts => { const attachments = existing.concat(newAtts); const noteObj = { title, content, attachments }; if (editingIndex !== null) { notes[editingIndex] = noteObj; } else { notes.push(noteObj); } saveToStorage(); renderNotes(); closeModal(); }); }; // audio recording logic recordBtn.onclick = async () => { if (mediaRecorder && mediaRecorder.state === 'recording') { mediaRecorder.stop(); recordBtn.textContent = 'Record Audio'; return; } try { const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); mediaRecorder = new MediaRecorder(stream); recordingChunks = []; mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size) { recordingChunks.push(e.data); } }; mediaRecorder.onstop = () => { const blob = new Blob(recordingChunks, { type: 'audio/webm' }); const reader = new FileReader(); reader.onload = e => { // append to attachments list (in UI only; will be saved on Save click) const obj = { name: `Recording_${new Date().toISOString()}.webm`, type: 'audio/webm', data: e.target.result }; // show preview in attachments list const div = document.createElement('div'); div.textContent = obj.name; attachmentList.appendChild(div); // store temporarily by pushing to fileInput's files (not possible) or storing separately; we'll push to a hidden array // We'll use the fileInput's dataset to store additional attachments const extras = JSON.parse(fileInput.dataset.extras || '[]'); extras.push(obj); fileInput.dataset.extras = JSON.stringify(extras); }; reader.readAsDataURL(blob); }; mediaRecorder.start(); recordBtn.textContent = 'Stop Recording'; } catch (err) { alert('Could not start recording: ' + err.message); } }; // Modify save logic to also include extra attachments from recordings saveNoteBtn.addEventListener('click', () => { // This is handled above; but we also need to include extras from recording }); // Overwrite save function to handle extras after attachments conversion const originalSave = saveNoteBtn.onclick; saveNoteBtn.onclick = () => { const title = noteTitle.value.trim(); const content = noteContent.value.trim(); const existing = editingIndex !== null ? notes[editingIndex].attachments.slice() : []; const files = Array.from(fileInput.files); const extras = JSON.parse(fileInput.dataset.extras || '[]'); Promise.all(files.map(file => { return new Promise(resolve => { const reader = new FileReader(); reader.onload = e => { resolve({ name: file.name, type: file.type, data: e.target.result }); }; reader.readAsDataURL(file); }); })).then(newAtts => { const attachments = existing.concat(newAtts).concat(extras); const noteObj = { title, content, attachments }; if (editingIndex !== null) { notes[editingIndex] = noteObj; } else { notes.push(noteObj); } // Reset extras and file input dataset fileInput.dataset.extras = '[]'; saveToStorage(); renderNotes(); closeModal(); }); }; // initialise on load renderNotes(); </script> </body> </html>
